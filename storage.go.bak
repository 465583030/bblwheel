package bblwheel

import (
	"encoding/binary"
	"time"

	"bytes"

	"github.com/boltdb/bolt"
)

//Open ....
func Open(uri string) (Storage, error) {
	db, err := bolt.Open(uri, 0600, &bolt.Options{Timeout: 30 * time.Second})
	if err != nil {
		return nil, err
	}
	store := &boltStorage{
		db:          db,
		kvBucket:    []byte("base_kv"),
		ttlBucket:   []byte("ttl_kv"),
		watchBucket: []byte("watch_kv"),
		events:      make(chan *Event, 1024),
	}
	go store.work()
	return store, nil
}

//Storage ....
type Storage interface {
	Put(string, string) error
	PutWithTTL(string, string, int64) error
	Get(string) (string, error)
	GetWithPrefix(string) (map[string]string, error)
	Delete(string) error
	DeleteWithPrefix(string) error
	Watch(string, func(*Event)) error
	WatchWithPrefix(string, func(*Event)) error
}

//EventType ....
type EventType string

const (
	//EventTypePut ....
	EventTypePut EventType = "PUT"
	//EventTypeDelete ....
	EventTypeDelete EventType = "DELETE"
)

//Event ....
type Event struct {
	Type  EventType
	Key   string
	Value string
}

type boltStorage struct {
	db          *bolt.DB
	kvBucket    []byte
	ttlBucket   []byte
	watchBucket []byte
	events      chan *Event
}

func (s *boltStorage) Put(key, value string) error {
	return s.PutWithTTL(key, value, 0)
}

func (s *boltStorage) PutWithTTL(key, value string, ttl int64) error {
	tx, err := s.db.Begin(true)
	if err != nil {
		return err
	}
	kv := tx.Bucket(s.kvBucket)
	kv.Put([]byte(key), []byte(value))
	ttlb := tx.Bucket(s.ttlBucket)
	if ttl > 0 {
		b := make([]byte, 8)
		binary.LittleEndian.PutUint64(b, uint64(ttl))
		ttlb.Put([]byte(key), b)
	}
	if err := tx.Commit(); err != nil {
		return err
	}
	s.events <- &Event{EventTypePut, key, value}
	return nil
}

func (s *boltStorage) Get(key string) (string, error) {
	var val = []byte{}
	err := s.db.View(func(tx *bolt.Tx) error {
		kv := tx.Bucket(s.kvBucket)
		val = kv.Get([]byte(key))
		return nil
	})
	return string(val), err
}

func (s *boltStorage) GetWithPrefix(key string) (map[string]string, error) {
	m := map[string]string{}
	err := s.db.View(func(tx *bolt.Tx) error {
		cur := tx.Bucket([]byte(s.kvBucket)).Cursor()
		for k, v := cur.Seek([]byte(key)); bytes.HasPrefix(k, []byte(key)); k, v = cur.Next() {
			m[string(k)] = string(v)
		}
		return nil
	})
	return m, err
}

func (s *boltStorage) Delete(key string) error {
	return s.db.Update(func(tx *bolt.Tx) error {
		kv := tx.Bucket(s.kvBucket)
		v := kv.Get([]byte(key))
		if err := kv.Delete([]byte(key)); err != nil {
			return err
		}
		s.events <- &Event{EventTypeDelete, key, string(v)}
		return nil
	})
}

func (s *boltStorage) DeleteWithPrefix(key string) error {
	return s.db.Update(func(tx *bolt.Tx) error {
		cur := tx.Bucket([]byte(s.kvBucket)).Cursor()
		for k, v := cur.Seek([]byte(key)); bytes.HasPrefix(k, []byte(key)); k, v = cur.Next() {
			if err := cur.Delete(); err != nil {
				return err
			}
			s.events <- &Event{EventTypeDelete, string(k), string(v)}
		}
		return nil
	})
}

func (s *boltStorage) Watch(key string, onEvent func(*Event)) error {
	return nil
}

func (s *boltStorage) WatchWithPrefix(key string, onEvent func(*Event)) error {
	return nil
}

func (s *boltStorage) work() {
	for e := range s.events {
		switch e.Type {
		case EventTypePut:
		case EventTypeDelete:
		}
	}
}
